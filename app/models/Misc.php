<?php
namespace app\models;

use app\core;

class Misc {
    /**
     * Auto load classes
     *
     * @param $class
     */
    public static function loader($class) {
        // Set class name to upper case
        $class = explode('\\', $class);
        $className = end($class);
        $key = key($class);
        $class[$key] = ucfirst($className);
        $class = implode($class, '\\');
        require_once BASE_DIR . '/' . str_replace('\\', '/', $class) . '.php';
    }

    /**
     *
     * empty() function for multiple values
     *
     * @link    http://stackoverflow.com/questions/4993104/using-ifempty-with-multiple-variables-not-in-an-array
     * @return      boolean
     *
     */
    public static function mEmpty() {
        foreach (func_get_args() as $arg)
            //if (!isset($arg)) {
            //    continue;
            //} else
            if (empty($arg))
                continue;
            else
                return false;
        return true;
    }

    /**
     *
     * Escape and execute a command
     * $return['status'] = string, contains a error message from the program executed
     * $return['result'] = int contains a error code from the program executed
     * $return['code_type'] = error code generated by third party tool or phpietadmin?
     *
     * @param    string $command command to be executed
     * @return   array
     *
     */
    public static function logExec($command) {
        $registry = core\Registry::getInstance();
        $logging = $registry->get('logging');
        $logging->log_debug_result();
        $return = [];
        exec(escapeshellcmd($command) . ' 2>&1', $return['status'], $return['result']);
        $return['code_type'] = 'extern';
        return $return;
    }

    /**
     *  array_search function with partial match
     *
     * @param string $needle
     * @param array $haystack
     * @link https://gist.github.com/branneman/951847
     * @return bool
     *
     */
    public static function arrayFind($needle, array $haystack) {
        foreach ($haystack as $key => $value) {
            if (false !== stripos($value, $needle)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Recursive function to find a iqn in array
     *
     * @param string $iqn
     * @param array $haystack
     * @return int|bool
     */
    public static function array_find_iqn($iqn, array $haystack) {
        foreach ($haystack as $key => $value) {
            if (false !== stripos($value, $iqn)) {
                // iqn is in $haystack[$key]
                // but we need to be sure
                // the first object and the iqn are separated by space
                // extract the iqn and compare it
                preg_match('([^\s]+)', $haystack[$key], $matches);

                if ($matches[0] === $iqn) {
                    return $key;
                } else {
                    unset($haystack[$key]);
                    self::array_find_iqn($iqn, $haystack);
                }
            }
        }
        return false;
    }

    /**
     * array_search for multidimensional arrays
     *
     * @param string $needle
     * @param array $haystack
     * @return int|bool
     *
     */
    public static function recursiveArraySearch($needle, array $haystack) {
        foreach ($haystack as $key => $value) {
            $current_key = $key;
            if ($needle === $value OR (is_array($value) && self::recursiveArraySearch($needle, $value) !== false)) {
                return $current_key;
            }
        }
        return false;
    }

    /**
     * Version file parser
     *
     * @return mixed
     * @throws \Exception
     */
    public static function getVersionFile() {
        if (file_exists(VERSION_FILE)) {
            $versionFile = json_decode(file_get_contents(VERSION_FILE), true);
            if ($versionFile !== NULL) {
                return $versionFile;
            } else {
                throw new \Exception('Version file is invalid!');
            }
        } else {
            throw new \Exception('Version file not found!');
        }
    }

    /**
     * Checks if an incoming request is an ajax
     *
     * @return bool
     */
    public static function isXHttpRequest() {
        if (isset($_SERVER['HTTP_X_REQUESTED_WITH']) && !empty($_SERVER['HTTP_X_REQUESTED_WITH']) && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) === 'xmlhttprequest') {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Collects data for the phpietadmin dashboard
     *
     * @return array
     */
    public static function get_dashboard_data() {
        $data['hostname'] = file_get_contents('/etc/hostname');

        // get version and release
        $versionFile = self::getVersionFile();
        $data['phpietadminversion'] = $versionFile['version'];
        $data['release'] = $versionFile['release'];

        $data['distribution'] = shell_exec('lsb_release -sd');

        $hwdata = file('/proc/cpuinfo');
        $hwdata[4] = str_replace("model", '', $hwdata[4]);
        $hwdata[4] = str_replace("name", '', $hwdata[4]);
        $data['cpu'] = str_replace(":", '', $hwdata[4]);

        $data['uptime'] = shell_exec('uptime -p');
        $data['systemstart'] = shell_exec('uptime -s');

        preg_match('/load average: (.*)/', shell_exec('uptime'), $matches);
        $data['currentload'] = $matches[1];

        $mem = file('/proc/meminfo');
        preg_match('/[0-9]+/', $mem[0], $matches);
        $data['memtotal'] = intval($matches[0] / 1024);

        preg_match('/[0-9]+/', $mem[1], $matches);
        $data['memused'] = intval($matches[0] / 1024);

        $data['systemtime'] = shell_exec('date');
        $data['kernel'] = shell_exec('uname -r');

        return $data;
    }

    public static function isValidAuthFile() {
        if (file_exists(AUTH_FILE)) {
            if (filesize(AUTH_FILE) !== 0) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * Tail implementation in php
     *
     * @link http://www.geekality.net/2011/05/28/php-tail-tackling-large-files/
     * @param $filename
     * @param int $lines
     * @param int $buffer
     * @return string
     */
    public static function tail($filename, $lines = 10, $buffer = 4096) {
        if (file_exists($filename) && filesize($filename) != 0) {
            // Open the file
            $f = fopen($filename, "rb");

            // Jump to last character
            fseek($f, -1, SEEK_END);

            // Read it and adjust line number if necessary
            // (Otherwise the result would be wrong if file doesn't end with a blank line)
            if (fread($f, 1) != "\n") $lines -= 1;

            // Start reading
            $output = '';
            $chunk = '';

            // While we would like more
            while (ftell($f) > 0 && $lines >= 0) {
                // Figure out how far back we should jump
                $seek = min(ftell($f), $buffer);

                // Do the jump (backwards, relative to where we are)
                fseek($f, -$seek, SEEK_CUR);

                // Read a chunk and prepend it to our output
                $output = ($chunk = fread($f, $seek)) . $output;

                // Jump back to where we started reading
                fseek($f, -mb_strlen($chunk, '8bit'), SEEK_CUR);

                // Decrease our line counter
                $lines -= substr_count($chunk, "\n");
            }

            // While we have too many lines
            // (Because of buffer size we might have read too many)
            while ($lines++ < 0) {
                // Find first newline and remove all text before that
                $output = substr($output, strpos($output, "\n") + 1);
            }

            // Close file and return
            fclose($f);

            $data = array_filter(explode("\n", $output));

            foreach ($data as $line) {
                $rows[] = str_getcsv($line, ' ');
            }

            return $rows;
        } else {
            return false;
        }
    }

    /**
     * Create a "normal" array from a multidimensional one
     *
     * @param array $array multidimensional array to convert
     * @return array
     * @link http://stackoverflow.com/questions/6785355/convert-multidimensional-array-into-single-array/6785366#6785366
     *
     */
    public static function arrayFlatten(array $array) {
        if (!is_array($array)) {
            return FALSE;
        }
        $result = array();
        foreach ($array as $key => $value) {
            if (is_array($value)) {
                $result = array_merge($result, self::arrayFlatten($value));
            } else {
                $result[$key] = $value;
            }
        }
        return $result;
    }

    public static function echoHtmlEscapedString($string) {
        echo htmlspecialchars($string);
        return "";
    }

    /**
     * Backup a file to the phpietadmin backup dir
     * Only $maxBackups will be stored, before the oldest is deleted
     *
     * @param        $path
     * @param string $type
     * @return bool
     */
    public static function backupFile($path, $type = 'file') {
        $registry = core\Registry::getInstance();
        $database = $registry->get('database');

        $backupDir = $database->get_config('backupDir')['value'];
        $maxBackups = $database->get_config('maxBackups')['value'];
        $backupDirFiles = $backupDir . '/files';
        $backupDirDb = $backupDir . '/db';

        // Create backup folder
        if (!is_dir($backupDirFiles)) {
            mkdir($backupDirFiles);
        }
        if (!is_dir($backupDirDb)) {
            mkdir($backupDirDb);
        }

        // Delete old backup files, but keep at least $maxBackups
        $files = glob($backupDirFiles . '/*');
        array_multisort(array_map('filemtime', $files), SORT_NUMERIC, SORT_ASC, $files);
        if (count($files) >= $maxBackups) {
            if (file_exists($files[0])) {
                unlink($files[0]);
            }
        }

        // Delete old db backups, but keep at least $maxBackups
        $files = glob($backupDirDb . '/*');
        array_multisort(array_map('filemtime', $files), SORT_NUMERIC, SORT_ASC, $files);
        if (count($files) > $maxBackups) {
            if (file_exists($files[0])) {
                unlink($files[0]);
            }
        }

        if ($type === 'file') {
            if (file_exists($path)) {
                $filename = array_pop(explode('/', $path));
                return copy($path, $backupDirFiles . '/' . $filename . '_' . time());
            } else {
                return false;
            }
        } else if ($type === 'db') {
            if (file_exists($path)) {
                $filename = array_pop(explode('/', $path));
                return copy($path, $backupDirDb . '/' . $filename . '_' . time());
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
}
